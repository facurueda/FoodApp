(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = global || self, global.JSONCache = factory());
}(this, (function () { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * Flattens an object into another object
 * with key(in the form of 'a.b', 'a.c.0')-value pairs of dept=1
 *
 * @param target Object to be flattened
 * @param path String path not to include in the flattened object
 *
 * @returns
 */
function flatten(target) {
    return step(target);
}
function handleVal(val, path, result) {
    const isArray = Array.isArray(val);
    const isObject = val instanceof Object && !isArray;
    if (isObject) {
        if (Object.keys(val).length === 0) {
            result[path] = '{}';
        }
        else {
            step(val, path, result);
        }
    }
    else if (isArray) {
        if (val.length === 0) {
            result[path] = '[]';
        }
        else {
            val.forEach((item, i) => {
                const newPath = `${path}.${i}`;
                handleVal(item, newPath, result);
            });
        }
    }
    else {
        if (typeMap[val]) {
            result[path] = String(val);
        }
        else {
            result[path] = val;
        }
    }
}
const typeMap = {
    undefined: true,
    null: true,
    false: true,
    true: true,
};
/**
 * Moves into each embedded object in a step by step fashion
 *
 * @param object
 * @param prev Previous step's key
 */
function step(obj, path = '', result = {}) {
    Object.entries(obj).forEach(([key, val]) => {
        const encodedKey = encodeKey(key);
        const currPath = path ? `${path}.${encodedKey}` : encodedKey;
        handleVal(val, currPath, result);
    });
    return result;
}
/**
 * Unflatten/reverts the flattened object back
 * to original object
 *
 * @param target Flattened object
 *
 * @returns unflattened object
 */
function unflatten(target) {
    const result = {};
    Object.entries(target).forEach(([key, val]) => {
        const split = splitKey(key);
        let i = 0;
        // Get first and next key in the split key path
        let k1 = getkey(split[i]);
        let k2 = getkey(split[i + 1]);
        let tmp = result;
        // Loop until k1 has reached end of split
        while (k2 !== undefined) {
            const isObj = tmp[k1] instanceof Object;
            // If path has not been initialized,
            // then initialize it as an array/object
            // depending on next key (whether number or not?)
            if (!isObj)
                tmp[k1] = typeof k2 === 'number' ? [] : {};
            // Move one key forward
            tmp = tmp[k1];
            if (++i < split.length) {
                k1 = getkey(split[i]);
                k2 = getkey(split[i + 1]);
            }
        }
        tmp[k1] = unflattenMap[val] ? unflattenMap[val]() : val;
    });
    return result;
}
const unflattenMap = {
    '{}': () => ({}),
    '[]': () => [],
    'undefined': () => undefined,
    'null': () => null,
    'true': () => true,
    'false': () => false,
};
/**
 * Return the given key if it's a string else
 * parses it into number
 *
 * @param key
 *
 * @returns a string if it cannot be parsed to a number
 *           else returns the parsed number
 */
function getkey(key) {
    const parsedKey = Number(key);
    return isNaN(parsedKey) ? decodeKey(key) : parsedKey;
}
function encodeKey(key) {
    return key.replace(/\./g, '/.');
}
function decodeKey(key) {
    return key ? key.replace(/\/./g, '.') : key;
}
function splitKey(key) {
    return key.split(/(?<!\/)\./);
}

class JSONCache {
    /**
     * Intializes JSONStore instance
     * @param redisClient IORedis client
     * @param options Options for controlling the prefix
     */
    constructor(redisClient, options = {}) {
        this.redisClient = redisClient;
        this.options = options;
        this.options.prefix = options.prefix || 'jc:';
    }
    /**
     * Flattens the given json object and
     * stores it in Redis hashset
     *
     * @param key Redis key
     * @param obj JSON object to be stored
     * @param options
     */
    set(key, obj, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const flattened = flatten(obj);
            // this is done to allow storage of empty objects
            flattened.__jc_root__ = '0';
            yield this.redisClient.hmset.call(this.redisClient, this.getKey(key), flattened);
            if (options.expire)
                yield this.redisClient.expire.call(this.redisClient, this.getKey(key), options.expire);
        });
    }
    /**
     * Retrieves the hashset from redis and
     * unflattens it back to the original Object
     *
     * @param key Redis key
     * @param fields List of fields to be retreived from redis.
     *    This helps reduce network latency incase only a few fields are
     *    needed.
     *
     * @returns request object from the cache
     */
    get(key, ...fields) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.redisClient[fields.length > 0 ? 'hmget' : 'hgetall'].call(this.redisClient, this.getKey(key), ...fields);
            // Empty object is returned when
            // the given key is not present
            // in the cache
            if (Object.keys(result).length === 0) {
                return undefined;
            }
            delete result.__jc_root__;
            if (fields.length > 0) {
                return fields.reduce((res, field, i) => {
                    res[field] = result[i];
                    return res;
                }, {});
            }
            return unflatten(result);
        });
    }
    /**
     * Replace the entire hashset for the given key
     *
     * @param key Redis key
     * @param obj JSON Object of type T
     */
    rewrite(key, obj) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.redisClient.del.call(this.redisClient, this.getKey(key));
            yield this.set(key, obj);
        });
    }
    /**
     * Removes/deletes all the keys in the JSON Cache,
     * having the prefix.
     */
    clearAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.redisClient.keys.call(this.redisClient, `${this.options.prefix}*`);
            // Multi command for efficiently executing all the keys at once
            yield this.redisClient.multi(keys.map(k => ['del', k])).exec();
        });
    }
    /******************
     * PRIVATE METHODS
     ******************/
    getKey(key) {
        return `${this.options.prefix}${key}`;
    }
}

return JSONCache;

})));
