import { IOptions, ISetOptions } from '../interfaces';
declare type Transaction = any;
interface IJSONCache<T> {
    set(key: string, obj: T, options: ISetOptions): Promise<any>;
    get(key: string, ...fields: string[]): Promise<Partial<T> | undefined>;
    rewrite(key: string, obj: T, options?: ISetOptions): Promise<any>;
    clearAll(): Promise<any>;
    del(key: string): Promise<any>;
    setT(transaction: Transaction, key: string, obj: T, options: ISetOptions): Transaction;
    rewriteT(transaction: Transaction, key: string, obj: T, options?: ISetOptions): Transaction;
    delT(transaction: Transaction, key: string): Transaction;
}
/**
 * JSONCache eases the difficulties in storing a JSON in redis.
 *
 *  It stores the JSON in hashset for simpler get and set of required
 * fields. It also allows you to override/set specific fields in
 * the JSON without rewriting the whole JSON tree. Which means that it
 * is literally possible to `Object.deepAssign()`.
 *
 *   Everytime you store an object, JSONCache would store two hashset
 * in Redis, one for data and the other for type information. This helps
 * during retrieval of data, to restore the type of data which was originally
 * provided. All these workaround are needed because Redis DOES NOT support
 * any other data type apart from String.
 *
 * Well the easiest way is to store an object in Redis is
 * JSON.stringify(obj) and store the stringified result.
 * But this can cause issue when the obj is
 * too huge or when you would want to retrieve only specific fields
 * from the JSON but do not want to parse the whole JSON.
 *   Also note that this method would end up in returing all the
 * fields as strings and you would have no clue to identify the type of
 * field.
 */
export default class JSONCache<T = any> implements IJSONCache<T> {
    private options;
    private redisClientInt;
    private flattener;
    /**
     * Intializes JSONCache instance
     * @param redisClient RedisClient instance(Preferred ioredis - cient).
     *      It supports any redisClient instance that has
     *      `'hmset' | 'hmget' | 'hgetall' | 'expire' | 'del' | 'keys'`
     *      methods implemented
     * @param options Options for controlling the prefix
     */
    constructor(redisClient: any, options?: IOptions);
    /**
     * Flattens the given json object and
     * stores it in Redis hashset
     *
     * @param key Redis key
     * @param obj JSON object to be stored
     * @param options
     */
    set(key: string, obj: T, options?: ISetOptions): Promise<any>;
    /**
     * Flattens the given json object and
     * stores it in Redis hashset using
     * the given transaction
     *
     * @param transaction redis transaction
     * @param key Redis key
     * @param obj JSON object to be stored
     * @param options
     */
    setT(transaction: Transaction, key: string, obj: T, options?: ISetOptions): Transaction;
    /**
     * Retrieves the hashset from redis and
     * unflattens it back to the original Object
     *
     * @param key Redis key
     * @param fields List of fields to be retreived from redis.
     *    This helps reduce network latency incase only a few fields are
     *    needed.
     *
     * @returns request object from the cache
     */
    get(key: string, ...fields: string[]): Promise<Partial<T> | undefined>;
    /**
     * Replace the entire hashset for the given key
     *
     * @param key Redis key
     * @param obj JSON Object of type T
     */
    rewrite(key: string, obj: T, options?: ISetOptions): Promise<any>;
    /**
     * Replace the entire hashset for the given key
     *
     * @param transaction Redis transaction
     * @param key Redis key
     * @param obj JSON Object of type T
     */
    rewriteT(transaction: Transaction, key: string, obj: T, options?: ISetOptions): Transaction;
    /**
     * Removes/deletes all the keys in the JSON Cache,
     * having the prefix.
     */
    clearAll(): Promise<any>;
    /**
     * Removes the given key from Redis
     *
     * Please use this method instead of
     * directly using `redis.del` as this method
     * ensures that even the corresponding type info
     * is removed. It also ensures that prefix is
     * added to key, ensuring no other key is
     * removed unintentionally
     *
     * @param key Redis key
     */
    del(key: string): Promise<any>;
    /**
     * Removes the given key from Redis
     * using the given transaction
     *
     * Please use this method instead of
     * directly using `redis.del` as this method
     * ensures that even the corresponding type info
     * is removed. It also ensures that prefix is
     * added to key, ensuring no other key is
     * removed unintentionally
     *
     * @param transaction Redis transaction
     * @param key Redis key
     */
    delT(transaction: Transaction, key: string): Transaction;
    /******************
     * PRIVATE METHODS
     ******************/
    /**
     * Returns the redis storage key for storing data
     * by prefixing custom string, such that it
     * doesn't collide with other keys in usage
     *
     * @param key Storage key
     */
    private getKey;
    /**
     * Returns the redis storage key for storing
     * corresponding types by prefixing custom string,
     * such that it doesn't collide with other keys
     * in usage
     *
     * @param key Storage key
     */
    private getTypeKey;
}
export {};
